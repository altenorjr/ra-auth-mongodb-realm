/// <reference path="../types/realm/bson.d.ts" />
/// <reference path="../types/realm/app.d.ts" />

declare type StorageChangeListner = () => void;
/**
 * Implementors of this provide a simple key-value store
 */
interface Storage {
    /**
     * Get the value of a particular key in the storage.
     */
    get(key: string): string | null;
    /**
     * Set the value of a particular key in the storage.
     */
    set(key: string, value: string): void;
    /**
     * Remove the entry for a particular key from the storage.
     */
    remove(key: string): void;
    /**
     * Create a new store prefixed with a part of the key.
     */
    prefix(keyPart: string): Storage;
    /**
     * Clears all values stored in the storage.
     *
     * @param prefix Clear only values starting with this prefix.
     */
    clear(prefix?: string): void;
    /**
     * Add a callback function which will be called when the store updates.
     *
     * @param listener The listener callback to add.
     */
    addListener(listener: StorageChangeListner): void;
    /**
     * Remove a callback function which was previously added.
     *
     * @param listener The listener callback to remove.
     */
    removeListener(listener: StorageChangeListner): void;
}

/**
 * A `Storage` which will prefix a key part to every operation.
 */
declare class PrefixedStorage implements Storage {
    /**
     * The string separating two parts
     */
    private static PART_SEPARATOR;
    /**
     * The underlying storage to use for operations.
     */
    private storage;
    /**
     * The part of the key to prefix when performing operations.
     */
    private keyPart;
    /**
     * Construct a `Storage` which will prefix a key part to every operation.
     *
     * @param storage The underlying storage to use for operations.
     * @param keyPart The part of the key to prefix when performing operations.
     */
    constructor(storage: Storage, keyPart: string);
    /** @inheritdoc */
    get(key: string): string | null;
    /** @inheritdoc */
    set(key: string, value: string): void;
    /** @inheritdoc */
    remove(key: string): void;
    /** @inheritdoc */
    prefix(keyPart: string): Storage;
    /** @inheritdoc */
    clear(prefix?: string): void;
    /** @inheritdoc */
    addListener(listener: StorageChangeListner): void;
    /** @inheritdoc */
    removeListener(listener: StorageChangeListner): void;
}

/**
 * Create a `Storage` instance, default to the current environment
 *
 * @returns A LocalStorage instance if the window global is an object, MemoryStorage otherwise.
 *          Both will prefix keys with "realm-web".
 */
declare function createDefaultStorage(): Storage;

declare type Method = "GET" | "POST" | "DELETE" | "PUT";
declare type Headers = {
    [name: string]: string;
};
interface Request<RequestBody> {
    method: Method;
    url: string;
    timeoutMs?: number;
    headers?: Headers;
    body?: RequestBody | string;
}
interface Response {
    statusCode: number;
    headers: Headers;
    body: string;
}
declare type SuccessCallback = (response: Response) => void;
declare type ErrorCallback = (err: Error) => void;
interface ResponseHandler {
    onSuccess: SuccessCallback;
    onError: ErrorCallback;
}
interface NetworkTransport {
    fetchAndParse<RequestBody extends any, ResponseBody extends any>(request: Request<RequestBody>): Promise<ResponseBody>;
    fetchWithCallbacks<RequestBody extends any>(request: Request<RequestBody>, handler: ResponseHandler): void;
}

interface UserParameters {
    app: App<any>;
    id: string;
    accessToken: string | null;
    refreshToken: string | null;
}
declare enum UserState {
    Active = "active",
    LoggedOut = "logged-out",
    Removed = "removed"
}
/**
 * Representation of an authenticated user of an app.
 */
declare class User<FunctionsFactoryType extends object = Realm.DefaultFunctionsFactory, CustomDataType extends object = any> implements Realm.User<FunctionsFactoryType, CustomDataType> {
    /**
     * The app that this user is associated with.
     */
    readonly app: App<FunctionsFactoryType, CustomDataType>;
    readonly functions: FunctionsFactoryType & Realm.BaseFunctionsFactory;
    /**
     * Log in and create a user
     *
     * @param app The app used when logging in the user
     * @param credentials Credentials to use when logging in
     * @param fetchProfile Should the users profile be fetched? (default: true)
     */
    static logIn<FunctionsFactoryType extends object, CustomDataType extends object>(app: App<FunctionsFactoryType, CustomDataType>, credentials: Realm.Credentials, fetchProfile?: boolean): Promise<User<FunctionsFactoryType, CustomDataType>>;
    /**
     * Creates a user from the data stored in the storage of an `App` instance.
     *
     * @param app The app that the user was logged into.
     * @param userId The id of the user to restore.
     * @returns The user created from values retrieved from storage.
     */
    static hydrate<FunctionsFactoryType extends object, CustomDataType extends object>(app: App<FunctionsFactoryType, CustomDataType>, userId: string): User<FunctionsFactoryType, CustomDataType>;
    private _id;
    private _accessToken;
    private _refreshToken;
    private _profile;
    private transport;
    private storage;
    constructor({ app, id, accessToken, refreshToken }: UserParameters);
    /**
     * The automatically-generated internal id of the user.
     *
     * @returns The id of the user in the MongoDB Realm database.
     */
    get id(): string;
    /**
     * @returns The access token used to authenticate the user towards MongoDB Realm.
     */
    get accessToken(): string | null;
    /**
     * @returns The refresh token used to issue new access tokens.
     */
    get refreshToken(): string | null;
    /**
     * The state of the user is one of:
     * - "active" The user is logged in and ready.
     * - "logged-out" The user was logged in, but is no longer logged in.
     * - "removed" The user was logged in, but removed entirely from the app again.
     *
     * @returns The current state of the user.
     */
    get state(): UserState;
    get customData(): CustomDataType;
    get apiKeys(): Realm.Auth.ApiKeyAuth;
    /**
     * @returns Profile containing detailed information about the user.
     */
    get profile(): Realm.UserProfile;
    refreshProfile(): Promise<void>;
    logOut(): Promise<void>;
    /** @inheritdoc */
    linkCredentials(credentials: Realm.Credentials): Promise<void>;
    refreshAccessToken(): Promise<void>;
    refreshCustomData(): Promise<CustomDataType>;
    callFunction(name: string, ...args: any[]): Promise<any>;
    /**
     * Restore a user from the data stored in the storage of an `App` instance.
     */
    hydrate(): void;
    private decodeAccessToken;
}

/**
 * A request to be sent via the transport.
 * Note: This has a path instead of a url.
 */
interface Request$1<RequestBody> {
    /** HTTP method used when fetching */
    method: Method;
    /** Path of the resource to fetch */
    path?: string;
    /** Body to send when fetching */
    body?: RequestBody | string;
    /** Headers to send when fetching */
    headers?: {
        [name: string]: string;
    };
}
/**
 * A transport takes care of fetching resources, more specialized than the `realm-network-transport`
 */
interface Transport {
    /**
     * Fetch a network resource.
     *
     * @param request The request to issue towards the server
     */
    fetch<RequestBody extends any, ResponseBody extends any>(request: Request$1<RequestBody>): Promise<ResponseBody>;
    /**
     * Creates another transport from this instance, adding a prefix to its path.
     *
     * @param pathPrefix Path to prefix
     */
    prefix(pathPrefix: string): Transport;
}

declare type AppLocation = {
    /**
     * The hostname to be used when communicating with the app server.
     */
    hostname: string;
    /**
     * The physical location of the app server.
     */
    location: string;
    /**
     * The deployment model of an app
     */
    deploymentModel: "GLOBAL" | "LOCAL";
};
declare type AppLocationContext = {
    /**
     * An object with a property representing the location of an app.
     */
    location: Promise<AppLocation>;
};

declare type BaseRequest<RequestBody> = Request$1<RequestBody> & {
    /**
     * Should the location (derived base URL) of the app be ignored for this request?
     *
     * @default false
     */
    ignoreLocation?: boolean;
};
/**
 * A basic transport, wrapping a NetworkTransport from the "realm-network-transport" package, injecting a baseUrl.
 */
declare class BaseTransport implements Transport {
    /**
     * This base route will be prefixed requests issued through by the base transport
     */
    private static readonly DEFAULT_BASE_ROUTE;
    /**
     * Default headers that will always be sat on requests
     */
    private static readonly DEFAULT_HEADERS;
    /**
     * The underlying network transport.
     */
    private readonly networkTransport;
    /**
     * The base URL to prepend to paths.
     */
    private baseUrl;
    /**
     * The base URL to prepend to paths.
     */
    private readonly baseRoute;
    /**
     * An object used to derive the location of the app.
     */
    private readonly locationContext?;
    /**
     * Constructs a base transport, which takes paths (prepended by a base URL) instead of absolute urls.
     *
     * @param networkTransport The underlying network transport.
     * @param baseUrl The base URL to prepend to paths.
     * @param locationContext Optional object used to determine the actual base URL of the app.
     * @param baseRoute Optional base route to prepend to the base URL.
     */
    constructor(networkTransport: NetworkTransport | undefined, baseUrl: string, locationContext?: AppLocationContext, baseRoute?: string);
    /** @inheritdoc */
    fetch<RequestBody extends any = any, ResponseBody extends any = any>(request: BaseRequest<RequestBody>): Promise<ResponseBody>;
    /** @inheritdoc */
    prefix(pathPrefix: string): Transport;
    /**
     * Determines the base URL from the configuration or from the location context.
     *
     * @param ignoreLocation Ignore the location context.
     */
    determineBaseUrl(ignoreLocation: boolean): Promise<string>;
}

declare type AnonymousPayload = Realm.Credentials.AnonymousPayload;
declare type ApiKeyPayload = Realm.Credentials.ApiKeyPayload;
declare type EmailPasswordPayload = Realm.Credentials.EmailPasswordPayload;
declare type OAuth2RedirectPayload = Realm.Credentials.OAuth2RedirectPayload;
declare type GooglePayload = Realm.Credentials.GooglePayload;
declare type FacebookPayload = Realm.Credentials.FacebookPayload;
declare type FunctionPayload = Realm.Credentials.FunctionPayload;
declare type JWTPayload = Realm.Credentials.JWTPayload;
declare type ApplePayload = Realm.Credentials.ApplePayload;
/**
 * Instances of this class can be passed to the `app.logIn` method to authenticate an end-user.
 */
declare class Credentials<PayloadType extends object> implements Realm.Credentials<PayloadType> {
    /**
     * Creates credentials that logs in using the [Anonymous Provider](https://docs.mongodb.com/realm/authentication/anonymous/).
     *
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static anonymous(): Credentials<Realm.Credentials.AnonymousPayload>;
    /**
     * Creates credentials that logs in using the [API Key Provider](https://docs.mongodb.com/realm/authentication/api-key/).
     *
     * @param key The secret content of the API key.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static apiKey(key: string): Credentials<Realm.Credentials.ApiKeyPayload>;
    /**
     * Creates credentials that logs in using the [Email/Password Provider](https://docs.mongodb.com/realm/authentication/email-password/).
     * Note: This was formerly known as the "Username/Password" provider.
     *
     * @param email The end-users email address.
     * @param password The end-users password.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static emailPassword(email: string, password: string): Credentials<Realm.Credentials.EmailPasswordPayload>;
    /**
     * Creates credentials that logs in using the [Custom Function Provider](https://docs.mongodb.com/realm/authentication/custom-function/).
     *
     * @param payload The custom payload as expected by the server.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static function<PayloadType extends FunctionPayload = FunctionPayload>(payload: PayloadType): Credentials<PayloadType>;
    /**
     * Creates credentials that logs in using the [Custom JWT Provider](https://docs.mongodb.com/realm/authentication/custom-jwt/).
     *
     * @param token The JSON Web Token (JWT).
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static jwt(token: string): Credentials<Realm.Credentials.ApiKeyPayload>;
    /**
     * Creates credentials that logs in using the [Google Provider](https://docs.mongodb.com/realm/authentication/google/).
     *
     * @param redirectUrlOrAuthCode The URL that users should be redirected to or the auth code returned from Google.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static google<PayloadType extends object = OAuth2RedirectPayload | GooglePayload>(redirectUrlOrAuthCode: string): Credentials<PayloadType>;
    /**
     * Creates credentials that logs in using the [Facebook Provider](https://docs.mongodb.com/realm/authentication/facebook/).
     *
     * @param redirectUrlOrAccessToken The URL that users should be redirected to or the auth code returned from Facebook.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static facebook<PayloadType extends object = OAuth2RedirectPayload | FacebookPayload>(redirectUrlOrAccessToken: string): Credentials<PayloadType>;
    /**
     * Creates credentials that logs in using the [Apple ID Provider](https://docs.mongodb.com/realm/authentication/apple/).
     *
     * @param redirectUrlOrIdToken The URL that users should be redirected to or the id_token returned from Apple.
     * @returns The credentials instance, which can be passed to `app.logIn`.
     */
    static apple<PayloadType extends object = OAuth2RedirectPayload | ApplePayload>(redirectUrlOrIdToken: string): Credentials<PayloadType>;
    /**
     * The name of the authentication provider used when authenticating.
     * Note: This is the same as the type for all current authentication providers in the service and mainly required for forwards-compatibility.
     */
    readonly providerName: string;
    /**
     * The type of the authentication provider used when authenticating.
     */
    readonly providerType: string;
    /**
     * The data being sent to the service when authenticating.
     */
    readonly payload: PayloadType;
    constructor(name: string, type: "anon-user", payload: AnonymousPayload);
    constructor(name: string, type: "api-key", payload: ApiKeyPayload);
    constructor(name: string, type: "local-userpass", payload: EmailPasswordPayload);
    constructor(name: string, type: "custom-function", payload: FunctionPayload);
    constructor(name: string, type: "custom-token", payload: JWTPayload);
    constructor(name: string, type: "oauth2-google", payload: OAuth2RedirectPayload | GooglePayload);
    constructor(name: string, type: "oauth2-facebook", payload: OAuth2RedirectPayload | FacebookPayload);
    constructor(name: string, type: "oauth2-apple", payload: OAuth2RedirectPayload | ApplePayload);
}

/** @inheritdoc */
declare class EmailPasswordAuth implements Realm.Auth.EmailPasswordAuth {
    /**
     * The underlying transport.
     */
    private readonly transport;
    /**
     * Construct an interface to the email / password authentication provider.
     *
     * @param transport The underlying transport used to request the services.
     * @param providerName Optional custom name of the authentication provider.
     */
    constructor(transport: Transport, providerName?: string);
    /** @inheritdoc */
    registerUser(email: string, password: string): Promise<void>;
    /** @inheritdoc */
    confirmUser(token: string, tokenId: string): Promise<void>;
    /** @inheritdoc */
    resendConfirmationEmail(email: string): Promise<void>;
    /** @inheritdoc */
    resetPassword(token: string, tokenId: string, password: string): Promise<void>;
    /** @inheritdoc */
    sendResetPasswordEmail(email: string): Promise<void>;
    /** @inheritdoc */
    callResetPasswordFunction(email: string, password: string, args: any[]): Promise<void>;
}

/**
 * Storage specific to the app.
 */
declare class AppStorage extends PrefixedStorage {
    /**
     * Construct a storage for an `App`
     *
     * @param storage The underlying storage to wrap.
     * @param appId The id of the app.
     */
    constructor(storage: Storage, appId: string);
    /**
     * Reads out the list of user ids from storage.
     *
     * @returns A list of user ids.
     */
    getUserIds(): any[];
    /**
     * Sets the list of ids in storage.
     * Optionally merging with existing ids stored in the storage, by prepending these while voiding duplicates.
     *
     * @param userIds The list of ids to store.
     * @param mergeWithExisting Prepend existing ids to avoid data-races with other apps using this storage.
     */
    setUserIds(userIds: string[], mergeWithExisting: boolean): void;
    /**
     * Remove an id from the list of ids.
     *
     * @param userId The id of a User to be removed.
     */
    removeUserId(userId: string): void;
}

/**
 * Configuration to pass as an argument when constructing an app.
 */
interface AppConfiguration extends Realm.AppConfiguration {
    /**
     * Transport to use when fetching resources.
     */
    transport?: NetworkTransport;
    /**
     * Used when persisting app state, such as tokens of authenticated users.
     */
    storage?: Storage;
    /**
     * Should the location of the app be fetched to determine the base URL upon the first request?
     *
     * @default true
     */
    fetchLocation?: boolean;
}
/**
 * MongoDB Realm App
 */
declare class App<FunctionsFactoryType extends object = Realm.DefaultFunctionsFactory, CustomDataType extends object = any> implements Realm.App<FunctionsFactoryType, CustomDataType>, AppLocationContext {
    /** @inheritdoc */
    readonly functions: FunctionsFactoryType & Realm.BaseFunctionsFactory;
    /** @inheritdoc */
    readonly services: Realm.Services;
    /** @inheritdoc */
    readonly id: string;
    /**
     * Instances of this class can be passed to the `app.logIn` method to authenticate an end-user.
     */
    static readonly Credentials: typeof Credentials;
    /**
     * Default base url to prefix all requests if no baseUrl is specified in the configuration.
     */
    static readonly DEFAULT_BASE_URL = "https://stitch.mongodb.com";
    /**
     * A transport adding the base route prefix to all requests.
     */
    readonly baseTransport: BaseTransport;
    /**
     * A transport adding the base and app route prefix to all requests.
     */
    readonly appTransport: Transport;
    /** @inheritdoc */
    readonly emailPasswordAuth: EmailPasswordAuth;
    /**
     * Storage available for the app
     */
    readonly storage: AppStorage;
    /**
     * An array of active and logged-out users.
     * Elements in the beginning of the array is considered more recent than the later elements.
     */
    private users;
    /**
     * An promise of the apps location metadata.
     */
    private _location;
    /**
     * An helper used to open new and close current windows.
     */
    private oauth2;
    /**
     * Construct a Realm App, either from the Realm App id visible from the MongoDB Realm UI or a configuration.
     *
     * @param idOrConfiguration The Realm App id or a configuration to use for this app.
     */
    constructor(idOrConfiguration: string | AppConfiguration);
    /**
     * Switch user
     *
     * @param nextUser The user or id of the user to switch to
     */
    switchUser(nextUser: User<FunctionsFactoryType, CustomDataType>): void;
    /**
     * Log in a user
     *
     * @param credentials Credentials to use when logging in
     * @param fetchProfile Should the users profile be fetched? (default: true)
     */
    logIn(credentials: Realm.Credentials<any>, fetchProfile?: boolean): Promise<User<FunctionsFactoryType, CustomDataType>>;
    /**
     * @inheritdoc
     */
    removeUser(user: User<FunctionsFactoryType, CustomDataType>): Promise<void>;
    /**
     * The currently active user (or null if no active users exists)
     *
     * @returns the currently active user or null.
     */
    get currentUser(): User<FunctionsFactoryType, CustomDataType> | null;
    /**
     * All active and logged-out users:
     *  - First in the list are active users (ordered by most recent call to switchUser or login)
     *  - Followed by logged out users (also ordered by most recent call to switchUser or login).
     *
     * @returns An array of users active or loggedout users (current user being the first).
     */
    get allUsers(): Readonly<Realm.User<FunctionsFactoryType, CustomDataType>[]>;
    /**
     * Get the location metadata of an app.
     *
     * @returns A promise of the app's location metadata.
     */
    get location(): Promise<AppLocation>;
    /**
     * Perform the actual login, based on the credentials.
     * Either it decodes the credentials and instantiates a user directly or it calls User.logIn to perform a fetch.
     *
     * @param credentials Credentials to use when logging in
     * @param fetchProfile Should the users profile be fetched? (default: true)
     */
    private performLogIn;
    /**
     * Restores the state of the app (active and logged-out users) from the storage
     */
    private hydrate;
}

/**
 * Get or create a singleton Realm App from an id.
 *
 * @param id The Realm App id visible from the MongoDB Realm UI or a configuration
 * @returns The Realm App instance. Calling this function multiple times with the same id will return the same instance.
 */
declare function app(id: string): Realm.App<Realm.DefaultFunctionsFactory, any> | App<Realm.DefaultFunctionsFactory, any>;
/**
 * Handle an OAuth 2.0 redirect
 *
 * @param location An optional location to use (defaults to the windows current location)
 * @param storage Optional storage used to save any results from the location.
 */
declare function handleAuthRedirect(location?: Location, storage?: Storage): void;

export { App, Credentials, User, UserState, app, createDefaultStorage, handleAuthRedirect };
